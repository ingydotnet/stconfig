#!/bin/bash
alias ll='ls -l'
alias la='ls -la'
alias RM='rm -rf' # for Mr. dot Net
alias perlsw='perl -Mstrict -Mwarnings'
alias perldd='perl -MData::Dumper'
alias GETf='GET -UseS'
alias POSTf='POST -UseS'
alias HEADf='HEAD -UseS'
alias rc="rcontract-create"
alias rq='stedit -w dev-tasks "Release Queue"'

alias agu='sudo apt-get update'
alias agdu='sudo apt-get update; sudo apt-get dist-upgrade'
alias agi='sudo apt-get update; sudo apt-get install'
alias acs='apt-cache search'
alias acsh='apt-cache show'

for cmd in `find $HOME/stbin/ -name 'svn*'`; do
    svn_cmd=`basename $cmd`
    svk_cmd=`echo $svn_cmd | sed s/svn/svk/`
    alias $svk_cmd=$svn_cmd
done

# Extract fields from output
f() {
    N=$1
    shift;
    awk $@ "{print \$${N:-1}}";
}

abs_path() { perl -MCwd -le "print Cwd::abs_path(shift)" $1; }
scmcd() { cd $1; scm up; scm status; }
kiss() { command kiss "$@"; rehash; }
conceive() { command conceive "$@"; rehash; }
aginstall() { ~/stbin/aginstall "$@"; rehash; }

# Check for GNU before aliasing:
ls --version > /dev/null 2>&1 && alias ls='ls --classify --color=auto'
echo x | (grep x --color >/dev/null 2>&1) && alias grep='grep --color=auto'

   function cdnlw() { cd `abs_path $ST_CURRENT/nlw`
}; function CDnlw() { scmcd `abs_path $ST_CURRENT/nlw`
}; function cdtrunk() { cd $ST_TRUNK
}; function CDtrunk() { scmcd $ST_TRUNK
}; function cdcur() { cd `abs_path $ST_CURRENT`
}; function CDcur() { scmcd `abs_path $ST_CURRENT`
}; function cdcfg() { cd `abs_path $ST_CURRENT/stconfig`
}; function CDcfg() { scmcd `abs_path $ST_CURRENT/stconfig` && ./stconfig-setup
}
MAC_FILE="~/.nlw/etc/Socialtext/MAC.secret"
alias muckmac="rm $MAC_FILE; echo bemucked > $MAC_FILE"
alias accessd="cd /var/log/apache-perl/; ls"
alias vv='vim ~/.vimrc'
alias tl='test-less'
alias tlp='test-less --prove'
alias dict='/usr/bin/dict -dall'
alias pwdtitle='screentitle "$(basename $(pwd))/"';
cd() { builtin cd "$@"; pwdtitle; }
pushd() { builtin pushd "$@"; pwdtitle; }
popd() { builtin popd; pwdtitle; }
vim() { /usr/bin/vim "$@"; pwdtitle; }
alias viml='vim !! -l'
alias tail=multitail

# stedit aliases
alias stossedit='stedit -p -w stoss'
alias dgedit='stedit -p -w dev-guide'
alias dtedit='stedit -w dev-tasks'
alias rtedit='stedit -w regression-test'
alias stdedit='stedit -p -w stdev'

# Appliance project aliases
alias apm='wikrad -w appliance-manual "Appliance Project Plan"'
alias appedit='stedit -p -w appliance-project'
alias apmedit='stedit -p -w appliance-manual'
alias appiter='appedit -l iteration'
alias appiter='apmedit -l iteration'

function provelog() { NLW_APPCONFIG=syslog_level=debug prove "$@"; }

function stfreshen() {
    CDcur
    cdnlw
    ctags -R .. &
    dev-bin/fresh-dev-env-from-scratch
    muckmac
    prove -lv `find t/ -name '*.t' | perl -le '@x=<>; chomp(@x); print "$x[int(rand(@x))] $x[int(rand(@x))]"'`
    #t/page.t t/live/mega.t # TODO: make this random
}

# Handy for making sense of failing data-oriented tests.
tdiff() {
    prove -lv "$@" \
    | perl -ne 'print if /^not ok/ or s/^# //' \
    | vim-pager +'set filetype=diff'
}

ppout() {
    prefix=/tmp/nlw-postprocess-
    if [ -d "$prefix$(id -u www-data)" ]; then
        dir="$prefix$(id -u www-data)"
    elif [ -d "$prefix$(id -u)" ]; then
        dir="$prefix$(id -u)"
    else
        echo "Can't find any postprocess output."
        return
    fi

    if [ "$2" = 'last' ]; then
        builtin pushd $dir
        2="$(ls -t | head -1)"
        builtin popd
        if [ "$2" = '' ]; then
            echo "No entries; hence no last entry."
            return
        fi
    fi

    case "$1" in
        (cd)
            cd "$dir"
            ;;
        (ls)
            ls -rt "$dir/$2"
            ;;
        (echo)
            echo "$dir/$2"
            ;;
        (cat)
            if [ "$2" = '' ]; then
                _ppout_usage
            else
                cat "$dir/$2"
            fi
            ;;
        (page)
            if [ "$2" = '' ]; then
                _ppout_usage
            else
                ${PAGER:-less} "$dir/$2"
            fi
            ;;
        (edit)
            if [ "$2" = '' ]; then
                _ppout_usage
            else
                ${EDITOR:-vi} "$dir/$2"
            fi
            ;;
        (rm)
            if [ "$2" = '' ]; then
                rm -f "$dir/"*
            else
                rm -f "$dir/$2"
            fi
            ;;
         (*)
             _ppout_usage
             ;;
    esac
}

_ppout_usage() {
    cat <<'EOT'
ppout - Examine postprocess output.

USAGE

    ppout cd
    ppout ls [OUTFILE]
    ppout cat OUTFILE
    ppout page OUTFILE
    ppout edit OUTFILE
    ppout rm [OUTFILE]    - if OUTFILE is omitted, removes all output

OUTFILE can be 'last' which will manipulate the most recent file in the
directory instead.
EOT
}
