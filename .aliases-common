#!/bin/bash
alias ll='ls -l'
alias la='ls -la'
alias RM='rm -rf' # for Mr. dot Net

scmcd() { cd $1; scm up; scm status; }
kiss() { command kiss "$@"; rehash; }
conceive() { command conceive "$@"; rehash; }
aginstall() { ~/stbin/aginstall "$@"; rehash; }

# Check for GNU before aliasing:
ls --version > /dev/null 2>&1 && alias ls='ls --classify --color=auto'
echo x | (grep x --color >/dev/null 2>&1) && alias grep='grep --color=auto'

   function cdnlw() { cd $ST_TRUNK/nlw
}; function CDnlw() { scmcd $ST_TRUNK/nlw
}; function cdtrunk() { cd $ST_TRUNK
}; function CDtrunk() { scmcd $ST_TRUNK
}; function cdcfg() { cd $ST_TRUNK/stconfig
}; function CDcfg() { scmcd $ST_TRUNK/stconfig && ./stconfig-setup
}
MAC_FILE="~/.nlw/etc/Socialtext/MAC.secret"
alias muckmac="rm $MAC_FILE; echo bemucked > $MAC_FILE"
alias accessd="cd /var/log/apache-perl/; ls"
alias vv='vim ~/.vimrc'
alias tl='test-less'
alias tlp='test-less --prove'
alias dict='/usr/bin/dict -dall'
alias pwdtitle='screentitle "$(basename $(pwd))/"';
cd() { builtin cd "$@"; pwdtitle; }
pushd() { builtin pushd "$@"; pwdtitle; }
popd() { builtin popd; pwdtitle; }
vim() { /usr/bin/vim "$@"; pwdtitle; }
alias viml='vim !! -l'
alias tail=multitail

function provelog() { NLW_APPCONFIG=syslog_level=debug prove "$@"; }

function stfreshen() { 
    CDtrunk
    cdnlw
    ctags -R .. &
    dev-bin/fresh-dev-env-from-scratch
    muckmac
    prove -lv t/page.t t/live/mega.t # TODO: make this random
}

# Handy for making sense of failing data-oriented tests.
tdiff() {
    prove -lv "$@" \
    | perl -ne 'print if /^not ok/ or s/^# //' \
    | vim-pager +'set filetype=diff'
}

ppout() {
    prefix=/tmp/nlw-postprocess-
    if [ -d "$prefix$(id -u www-data)" ]; then
        dir="$prefix$(id -u www-data)"
    elif [ -d "$prefix$(id -u)" ]; then
        dir="$prefix$(id -u)"
    else
        echo "Can't find any postprocess output."
        return
    fi

    if [ "$2" = 'last' ]; then
        builtin pushd $dir
        2="$(ls -t | head -1)"
        builtin popd
        if [ "$2" = '' ]; then
            echo "No entries; hence no last entry."
            return
        fi
    fi

    case "$1" in
        (cd)
            cd "$dir"
            ;;
        (ls)
            ls -rt "$dir/$2"
            ;;
        (echo)
            echo "$dir/$2"
            ;;
        (cat)
            if [ "$2" = '' ]; then
                _ppout_usage
            else
                cat "$dir/$2"
            fi
            ;;
        (page)
            if [ "$2" = '' ]; then
                _ppout_usage
            else
                ${PAGER:-less} "$dir/$2"
            fi
            ;;
        (edit)
            if [ "$2" = '' ]; then
                _ppout_usage
            else
                ${EDITOR:-vi} "$dir/$2"
            fi
            ;;
        (rm)
            if [ "$2" = '' ]; then
                rm -f "$dir/"*
            else
                rm -f "$dir/$2"
            fi
            ;;
         (*)
             _ppout_usage
             ;;
    esac
}

_ppout_usage() {
    cat <<'EOT'
ppout - Examine postprocess output.

USAGE

    ppout cd
    ppout ls [OUTFILE]
    ppout cat OUTFILE
    ppout page OUTFILE
    ppout edit OUTFILE
    ppout rm [OUTFILE]    - if OUTFILE is omitted, removes all output

OUTFILE can be 'last' which will manipulate the most recent file in the
directory instead.
EOT
}
