#!/usr/bin/perl
use strict;
use warnings;
use Socialtext::Resting::Getopt qw/get_rester/;
use DateTime;
use Data::Dumper;
use Storable ();
use List::Util qw/sum max min reduce shuffle/;
use List::MoreUtils qw/:all/;
use Array::Heap;
use Clone qw/clone/;

# for using arrays-as-struct
use constant Start => 0;
use constant End   => 1;
use constant Tags  => 2;
use constant future => 0x7fffffff;

$| = 1;

my $r = get_rester(workspace => 'dev-tasks');
$r->accept('perl_hash');

my $rel_tag = shift || 'bonsaikitten' or die <<EOT;
USAGE: $0 <release> <page_to_upload_to_on_dev-tasks>
EOT
my $report_page = shift;

sub say ($);

my @state_order =
    qw/productmanagementpool inprep ready indev inqa awaitingsignoff/;
my %state_tags = (
    productmanagementpool => 'p',
    inprep                => 'P',
    ready                 => 'R',
    indev                 => 'D',
    inqa                  => 'Q',
    awaitingsignoff       => 'S',
);
my %state_display = (
    productmanagementpool => 'PMPool',
    inprep                => 'InPrep',
    ready                 => 'Ready',
    indev                 => 'InDev',
    inqa                  => 'InQA',
    awaitingsignoff       => 'Signoff',
);


my $pages;
my $cachefile = "cache-$rel_tag.sto";
if (-e $cachefile) {
    print "loading $cachefile...\n";
    $pages = Storable::retrieve($cachefile);
}
else {
    print "searching for pages tagged '$rel_tag'...\n";
    my $tmp_pages = $r->get_taggedpages($rel_tag);
    my $pages = [];
    print "downloading pages...\n";
    for my $page (@$tmp_pages) {
        print "fetching $page->{page_id}...\n";
        $page->{tags} = { map { lc($_) => 1 } @{$page->{tags}||[]} };
        unless ($page->{tags}{story}) {
            print "\tnot a story\n";
            next;
        }
        $page->{revisions} = $r->get_revisions($page->{page_id});
        push @$pages, $page;
    }
    print "saving cache...\n";
    Storable::store($pages => $cachefile);
}
print "done\n";

my @stories;
for my $story (@$pages) {
    my %state;

    my @revs;

    for my $rev (@{ $story->{revisions} || [] }) {
        delete $rev->{modified_time}; # useless; never changes.

        my %tags = map { $_ => 1 }
                   grep { exists $state_tags{$_} }
                   map { lc($_) } @{ $rev->{tags} };
        my $rev_ts = revision_id_to_datetime($rev->{revision_id});
        my $state = join(', ', grep { exists $tags{$_} } @state_order);
        push @revs, [$rev_ts->epoch, \%tags, $state];
    }

    my $info = summarize_revs(\@revs);

    $info->{spark} = '`' . join('',
        map { $state_tags{$_->{state}} || '-' } @{$info->{states}}) . '`';

    my $done = ($info->{states}[-1]{state} eq 'signedoff' or
                $info->{states}[-1]{state} eq '' &&
                    $info->{last_idx}{awaitingsignoff});
    $info->{is_done} = ! ! $done;

    $story->{stats} = $info;
    push @stories, $story;
}

simple_table();
my $flows = cumulative_flow_data();
#my $json = flot_cfd_json($flows);

if ($report_page) {
    print "Putting " . $r->server
        . '/' . $r->workspace . "/?$report_page ...\n";
    $r->put_page($report_page, page_content());
}

exit 0;

sub summarize_revs {
    my $revisions = shift;
    my @revs = sort { $a->[0] <=> $b->[0] } @$revisions;

    my @state_flow;
    {
        my ($at, $tags, $state) = @{shift(@revs)};
        push @state_flow, {
            at    => $at,
            tags  => {%$tags}, # copy
            state => $state,
            dur   => 0,
        };

        # Two tasks: 1) calculate the time spent in each kanban state 2)
        # collapse multiple edits within the same state to a single record in
        # a "state_flow".
        while (my $rev = shift @revs) {
            ($at, $tags, $state) = @$rev;
            my $prev = $state_flow[-1];
            my $time = $at - ($prev->{at} + $prev->{dur});

            if ($state eq $prev->{state}) {
                $prev->{dur} += $time;
            }
            else {
                push @state_flow, {
                    at    => $at,
                    tags  => {%$tags}, # copy
                    state => $state,
                    dur   => 0,
                };
            }
        }
    }

    my %total_per_state;
    for my $t (@state_order) {
        $total_per_state{$t} =
            sum map { $_->{dur} }
            grep { $_->{tags}{$t} }
            @state_flow;
    }

    my (%first, %last);
    my (%before_dur, %after_dur);
    for my $t (@state_order) {
        $first{$t} = firstidx { $_->{tags}{$t} } @state_flow;
        $last{$t}  =  lastidx { $_->{tags}{$t} } @state_flow;

        my ($before, $after);
        if ($first{$t}) {
            # duration before first tag instance
            $before_dur{$t} += $_->{dur}
                for @state_flow[0 .. $first{$t}-1];
        }
        if ($last{$t} && $last{$t} < $#state_flow) {
            # duration after last tag instance
            $after_dur{$t} += $_->{dur}
                for @state_flow[$last{$t}+1 .. $#state_flow];
        }
    }

    return {
        states => \@state_flow,
        first_idx => \%first,
        last_idx => \%last,
        dur_before_first => \%before_dur,
        dur_after_last => \%after_dur,
        total_per_state => \%total_per_state,
    };
}

sub revision_id_to_datetime {
    my $rev_id = shift;

    $rev_id =~ m/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/;
    return DateTime->new(
        year => $1, month => $2, day => $3,
        hour => $4, minute => $5, second => $6,
    );
}

sub delta_to_string {
    my $seconds = shift;
    if ($seconds < 3600) {
        my $minutes =  int($seconds / 60);
        return "0" if $minutes == 0;
        return "$minutes m";
    }
    elsif ($seconds < 3600 * (48+6)) {
        my $hours = int($seconds / 3600);
        return "$hours h";
    }
    else {
        my $days = sprintf('%0.1f', $seconds / 86400);
        return "$days d";
    }
}

sub _heapify_story_intervals {
    my $heap = shift;

    for my $story (@stories) {
        my $page_id = $story->{page_id};
        my $elem;
        for my $interval (@{$story->{stats}{states}}) {
            my $start = $interval->{at};
            my $end = $start + ($interval->{dur}||1) - 1;
            my %tags = map {
                $_ => { $page_id => 1}
            } keys %{$interval->{tags}};
            $elem = [$start,$end,\%tags];
            push_heap @$heap, $elem;
        }
        # make the last element end far in the future.
        $elem->[End] = future;
    }
}

# Convert a heapified set of story-intervals into an ordered sequence of
# slices suitable for generating cumulative-flow and or gant-chart-like
# information.  In theory, the data structure is updatable and could be used
# for time-window searching.
#
# Output is a list of discrete start-end-tags triplets in
# monitonically-increasing order by epoch timestamps.  The last element will
# have an end-time set to 0x7fffffff.  Each tag will have a hash of page_ids
# that have that tag in the interval.  So, for cumulative flow, count the
# number of pages associated with each tag.  A page missing from tags means
# hasn't entered the kanban yet.  The '' tag means its also not on the kanban.
#
# [
#   [12, 34, { foo => {story_a=>1, story_b=>1}                     }],
#   [35, 70, { foo => {story_b=>1},            bar => {story_a=>1} }],
#   [71, 75, { bar => {story_a=>1, story_b=>1}                     }],
#   [76, 80, { bar => {story_a=>1, story_b=>1}                     }],
#   [81, 85, { bar => {story_b=>1},            '' => {story_a=>1}  }],
#   [86, 0x7fffffff, { '' => {story_a=>1, story_b=>1} }],
# ]
#
# It's a bit hard to explain what's going on in the algorithm below, so i've
# used ASCII-art to illustrate.  Picture a timeline going from left to right.
# When the letters are above each other, that means they both occupy that
# slice of time.

sub cumulative_flow_data {
    my @heap;

    _heapify_story_intervals(\@heap);

    my @slices;
    my $cur = pop_heap @heap;
    my $next = $heap[0];
    while ($next) {
        # A is '$cur', B is '$next' and C is a merger of the two.  Dots mean a
        # continuation of some interval.
        if ($cur->[Start] == $next->[Start]) {
            # Case 1
            # AA......
            # BB.....
            if ($cur->[End] != $next->[End]) {
                if ($cur->[End] < $next->[End]) {
                    # Case 1b reduces to mirror of 1c
                    # AA       BBBB
                    # BBBB --> AA  
                    # CCBB     CCBB
#                     diag "1b swapping cur and next";
                    my $tmp = $next;
                    $next = $cur;
                    $cur = $tmp;
                }
                # Case 1c reduces to 1a if we split cur
                # AAAA     AAaa
                # BB   --> BB
                # CCAA     CCaa
#                 diag "1c splitting cur";
                my $new = [@$cur]; # shallow copy
                $new->[Start] = $next->[End]+1;
                $cur->[End] = $next->[End];
                push_heap @heap, $new;
            }

            # Case 1a
            # AA
            # BB
            # CC
#             diag "1a equal intervals";
            # merge: sum tag counts, union name set
            $cur->[Tags] = clone $cur->[Tags];
            for my $tag (keys %{$next->[Tags]}) {
                for my $name (keys %{$next->[Tags]{$tag}}) {
                    $cur->[Tags]{$tag}{$name} = 1;
                }
            }
            $next = pop_heap @heap;
        }
        else { # $cur->[Start] < $next->[Start] is implied
            # case 2
            # AA......
            #   BB.....
            if ($cur->[End] < $next->[Start]) {
                # Case 2a
                # AA     
                #   BB.....
#                 diag '2a no overlap';
#                 diag YAML::Dump($cur);
                push @slices, $cur;
                $cur = $next;
                $next = pop_heap @heap;
            }
            else {
                # Case 2b: reduction to Case 1a/1b
                # AAAA          aaAA
                #   BBB.... -->   BBB...
                # AACCB....     aaCCB...

                # Peel off the interval before the overlap (aa) and add that
                # to the results. Shorten the current (AA) and go to the next
                # loop which will hit Case 1
#                 diag "2b peeling off copy of cur";
                my $new = [@$cur];
                $new->[End] = $next->[Start]-1;
                $cur->[Start] = $next->[Start];
#                 diag YAML::Dump($new);
                push @slices, $new;
            }
        }
    }
#     diag YAML::Dump($cur);
    # last item doesn't overlap with anything, so just add it.
    push @slices, $cur;
    return \@slices;
}

{
    my $page_content;
    sub say ($) {
        my $msg = shift;
        print "$msg\n";
        if ($report_page) {
            $page_content ||= "This page is auto-generated.  Comments and changes will be lost.\n\n";
            $page_content .= "$msg\n";
        }
    }

    sub page_content { $page_content }
}

sub simple_table {
    say "Cumulative time spent in each state (including evenings and weekends)\n";
    say "| *Task* | *Sparkline* | " .
        join(' | ', map {"*$state_display{$_}*"} @state_order) . " |";
    for my $story (@stories) {
        my $info = $story->{stats};
        my $line = "| [$story->{name}] | $info->{spark} | ";
        $line .= " ".delta_to_string($info->{total_per_state}{$_} || 0)." |"
            for @state_order;
        say $line;
    }
    say "\n(Sparkline key: p=PMPool, P=InPrep, R=Ready, D=InDev, Q=InQA, S=AwaitingSignoff, dash for all other states)\n";
}
