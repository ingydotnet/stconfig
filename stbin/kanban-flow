#!/usr/bin/perl
use strict;
use warnings;
use Socialtext::Resting::Getopt qw/get_rester/;
use DateTime;
use Data::Dumper;
use Storable ();
use List::Util qw/sum max min reduce shuffle/;
use List::MoreUtils qw/:all/;

$| = 1;

my $r = get_rester(workspace => 'dev-tasks');
$r->accept('perl_hash');

my $rel_tag = shift || 'bonsaikitten' or die <<EOT;
USAGE: $0 <release> <page_to_upload_to_on_dev-tasks>
EOT
my $report_page = shift;

sub say ($);

my @state_order = qw/productmanagementpool inprep ready indev inqa awaitingsignoff/;
my %state_tags = (
    productmanagementpool => 'p',
    inprep => 'P',
    ready => 'R',
    indev => 'D',
    inqa => 'Q',
    awaitingsignoff => 'S',
);
my %state_display = (
    productmanagementpool => 'PMPool',
    inprep => 'InPrep',
    ready => 'Ready',
    indev => 'InDev',
    inqa => 'InQA',
    awaitingsignoff => 'Signoff',
);


my $pages;
my $cachefile = "cache-$rel_tag.sto";
if (-e $cachefile) {
    print "loading $cachefile...\n";
    $pages = Storable::retrieve($cachefile);
}
else {
    print "searching for pages tagged '$rel_tag'...\n";
    my $tmp_pages = $r->get_taggedpages($rel_tag);
    my $pages = [];
    print "downloading pages...\n";
    for my $page (@$tmp_pages) {
        print "fetching $page->{page_id}...\n";
        $page->{tags} = { map { lc($_) => 1 } @{$page->{tags}||[]} };
        unless ($page->{tags}{story}) {
            print "\tnot a story\n";
            next;
        }
        $page->{revisions} = $r->get_revisions($page->{page_id});
        push @$pages, $page;
    }
    print "saving cache...\n";
    Storable::store($pages => $cachefile);
}
print "done\n";

my @stories;
for my $story (@$pages) {
    my %state;

    my @revs;

    for my $rev (@{ $story->{revisions} || [] }) {
        delete $rev->{modified_time}; # useless; never changes.

        my %tags = map { $_ => 1 }
                   grep { exists $state_tags{$_} }
                   map { lc($_) } @{ $rev->{tags} };
        my $rev_ts = revision_id_to_datetime($rev->{revision_id});
        my $state = join(', ', grep { exists $tags{$_} } @state_order);
        push @revs, [$rev_ts->epoch, \%tags, $state];
    }

    my $info = summarize_revs(\@revs);

    $info->{spark} = '`' . join('',
        map { $state_tags{$_->{state}} || '-' } @{$info->{states}}) . '`';

    my $done = ($info->{states}[-1]{state} eq 'signedoff' or
                $info->{states}[-1]{state} eq '' &&
                    $info->{last_idx}{awaitingsignoff});
    $info->{is_done} = ! ! $done;

    $story->{stats} = $info;
    push @stories, $story;
}

simple_table();

if ($report_page) {
    print "Putting " . $r->server
        . '/' . $r->workspace . "/?$report_page ...\n";
    $r->put_page($report_page, page_content());
}

exit 0;

sub summarize_revs {
    my $revisions = shift;
    my @revs = sort { $a->[0] <=> $b->[0] } @$revisions;

    my @state_flow;
    {
        my ($at, $tags, $state) = @{shift(@revs)};
        push @state_flow, {
            at    => $at,
            tags  => {%$tags}, # copy
            state => $state,
            dur   => 0,
        };

        # Two tasks: 1) calculate the time spent in each kanban state 2)
        # collapse multiple edits within the same state to a single record in
        # a "state_flow".
        while (my $rev = shift @revs) {
            ($at, $tags, $state) = @$rev;
            my $prev = $state_flow[-1];
            my $time = $at - ($prev->{at} + $prev->{dur});

            if ($state eq $prev->{state}) {
                $prev->{dur} += $time;
            }
            else {
                push @state_flow, {
                    at    => $at,
                    tags  => {%$tags}, # copy
                    state => $state,
                    dur   => 0,
                };
            }
        }
    }

    my %total_per_state;
    for my $t (@state_order) {
        $total_per_state{$t} =
            sum map { $_->{dur} }
            grep { $_->{tags}{$t} }
            @state_flow;
    }

    my (%first, %last);
    my (%before_dur, %after_dur);
    for my $t (@state_order) {
        $first{$t} = firstidx { $_->{tags}{$t} } @state_flow;
        $last{$t}  =  lastidx { $_->{tags}{$t} } @state_flow;

        my ($before, $after);
        if ($first{$t}) {
            # duration before first tag instance
            $before_dur{$t} += $_->{dur}
                for @state_flow[0 .. $first{$t}-1];
        }
        if ($last{$t} && $last{$t} < $#state_flow) {
            # duration after last tag instance
            $after_dur{$t} += $_->{dur}
                for @state_flow[$last{$t}+1 .. $#state_flow];
        }
    }

    return {
        states => \@state_flow,
        first_idx => \%first,
        last_idx => \%last,
        dur_before_first => \%before_dur,
        dur_after_last => \%after_dur,
        total_per_state => \%total_per_state,
    };
}

sub revision_id_to_datetime {
    my $rev_id = shift;

    $rev_id =~ m/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/;
    return DateTime->new(
        year => $1, month => $2, day => $3,
        hour => $4, minute => $5, second => $6,
    );
}

sub delta_to_string {
    my $seconds = shift;
    if ($seconds < 3600) {
        my $minutes =  int($seconds / 60);
        return "0" if $minutes == 0;
        return "$minutes m";
    }
    elsif ($seconds < 3600 * (48+6)) {
        my $hours = int($seconds / 3600);
        return "$hours h";
    }
    else {
        my $days = sprintf('%0.1f', $seconds / 86400);
        return "$days d";
    }
}

{
    my $page_content;
    sub say ($) {
        my $msg = shift;
        print "$msg\n";
        if ($report_page) {
            $page_content ||= "This page is auto-generated.  Comments and changes will be lost.\n\n";
            $page_content .= "$msg\n";
        }
    }

    sub page_content { $page_content }
}

sub simple_table {
    say "Cumulative time spent in each state (including evenings and weekends)\n";
    say "| *Task* | *Sparkline* | " .
        join(' | ', map {"*$state_display{$_}*"} @state_order) . " |";
    for my $story (@stories) {
        my $info = $story->{stats};
        my $line = "| [$story->{name}] | $info->{spark} | ";
        $line .= " ".delta_to_string($info->{total_per_state}{$_} || 0)." |"
            for @state_order;
        say $line;
    }
    say "\n(Sparkline key: p=PMPool, P=InPrep, R=Ready, D=InDev, Q=InQA, S=AwaitingSignoff, dash for all other states)\n";
}

