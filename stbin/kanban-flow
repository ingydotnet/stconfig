#!/usr/bin/perl
use strict;
use warnings;
use Socialtext::Resting::Getopt qw/get_rester/;
use DateTime;
use Data::Dumper;

my $r = get_rester(workspace => 'dev-tasks');
my $tag = shift || 'allyourbase' or die <<EOT;
USAGE: $0 <release>
EOT
my $page = shift;
my $DEBUG = 0;

sub say ($);

my %state_tags = map { $_ => 1 } 
    qw/ProductManagementPool InPrep Ready InDev InQA AwaitingSignoff/;
$r->accept('perl_hash');
my $stories = $r->get_taggedpages($tag);

for my $story (@$stories) {
    warn Dumper $story if $DEBUG;
    my %story_tags = map { lc($_) => 1 } @{ $story->{tags} };
    next unless $story_tags{story};

    say "[$story->{name}]";
    my $revisions = $r->get_revisions($story->{page_id});
    my %story_state;
    for my $rev (@$revisions) {
        my %rev_tags = map { $_ => 1 } @{ $rev->{tags} };
        my $rev_ts = revision_id_to_datetime($rev->{revision_id});
        for my $tag (keys %rev_tags) {
            next unless $state_tags{$tag};
            if (not defined $story_state{$tag}) {
                $story_state{$tag}{first_start} = $rev_ts;
                $story_state{$tag}{start} = $rev_ts;
                warn "      first $tag - $rev_ts\n" if $DEBUG;
            }
            elsif ($story_state{$tag}{done}) {
                $story_state{$tag}{start} = $rev_ts;
                delete $story_state{$tag}{done};
                warn "      again $tag - $rev_ts\n" if $DEBUG;
            }
            else {
                warn "      still in $tag - $rev_ts\n" if $DEBUG;
            }
        }
        for my $tag (keys %story_state) {
            next if $rev_tags{$tag};
            next if $story_state{$tag}{done};
            $story_state{$tag}{done} = $rev_ts;
            my $start_ts = $story_state{$tag}{start};
            my $duration = duration_to_string($start_ts, $rev_ts);
            say "** $tag finished in $duration";
        }
#        warn Dumper $rev;
    }

    for my $tag (keys %story_state) {
        next if $story_state{$tag}{done};
        my $duration = duration_to_string($story_state{$tag}{start} => DateTime->now);
        say "* Currently in $tag for $duration";
    }
    if (my $done_ts = $story_state{'AwaitingSignoff'}{done}) {
        # story is "finished"
        for my $tag (qw/InPrep Ready InDev/) {
            my $start_ts = $story_state{$tag}{first_start};
            next unless defined $start_ts;
            my $d = duration_to_string($start_ts, $done_ts);
            say "* Took $d from $tag";
        }
    }
    say "";
}

if ($page) {
    print "\nUploading to '$page'\n";
    $r->put_page($page, page_content());
}

exit;

sub revision_id_to_datetime {
    my $rev_id = shift;

    $rev_id =~ m/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/;
    return DateTime->new(
        year => $1, month => $2, day => $3,
        hour => $4, minute => $5, second => $6,
    );
}

sub duration_to_string {
    my $start = shift;
    my $stop  = shift;
    my $start_epoch = $start->epoch;
    my $stop_epoch  = $stop->epoch;
    my $seconds = $stop_epoch - $start_epoch;

    my $hour = 60 * 60;
    if ($seconds < $hour) {
        my $minutes = 0;
        while ($seconds > 60) { $seconds -= 60; $minutes++ }
        return "$minutes minutes";
    }
    elsif ($seconds < $hour * 40) {
        my $hours = 0;
        while ($seconds > $hour) { $seconds -= $hour; $hours++ }
        return "$hours hours";
    }
    else {
        my $days = 0;
        my $day = $hour * 24;
        while ($seconds > $day) { $seconds -= $day; $days++ }
        return "$days days";
    }
}

{
    my $page_content;
    sub say ($) {
        my $msg = shift;
        print "$msg\n";
        if ($page) {
            $page_content ||= "This page is auto-generated.  Comments and changes will be lost.\n\n";
            $page_content .= "$msg\n";
        }
    }

    sub page_content { $page_content }
}

