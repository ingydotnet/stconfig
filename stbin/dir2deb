#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw(cwd abs_path);
use File::Basename qw(basename);
use File::Copy qw(copy);
use File::Copy::Recursive qw(dircopy);
use File::Find::Rule;
use File::Path qw(mkpath);
use File::Slurp qw(write_file);
use File::Spec::Functions qw(catdir catfile);
use File::Temp qw(tempdir);
use Getopt::Long qw(GetOptions :config bundling);
use IPC::Run qw(run timeout);
use POSIX qw(strftime);

#############################################################################
# HACKING NOTES:
#
# The basic idea of this tool is to create a Debian package from a given
# directory.  Various options can be given to say where the directory is,
# where it's rooted on the installed machine, what permissions dirs/files
# have, and what files/dirs get excludes.
#
# The basic strategy to achieve the above is as follows:
#
# 1) Rerun the program under fakeroot(1), if not already.  Fakeroot lets us
# create Debian packages which contain tarballs of data with the proper
# permissions, permissions you might normally not be able to set.
#
# 2) Copy the data into a temporary working directory.  This is done so we can
# organize the data the way it will look when it's installed.  I.e. we do this
# so we can obey the value of --root.
#
# 3) Build the package control file.  This is a metadata file used by the
# Debian packaging tools.  It contains things like the size of the package and
# information about what the package contains.  It has a specific format.  The
# size of the package is computed using du(1).
#
# 4) Copy the data into the package.  Yes, we copy twice.  A more efficient
# process would merge this step with step (2).  However, timing tests show
# this not the bottle neck except for very huge packages.
#
# 5) Create the debian package using dpkg-deb(1).  This does the magic of
# building the .deb file for us, using the control file as input.  See the
# notes below.
#
# 6) The created .deb is then copied out of the temporary working directory.
#
# NOTES ON dpkg-deb(1):
#
# The dpkg-deb(1) tool excepts a specific format as input.  For a package
# called "my-silly-package" it wants the following directory layout as input:
#
# my-silly-package/
# my-silly-package/DEBIAN/
# my-silly-package/DEBIAN/control
# my-silly-package/...whatever...
#
# The contents of the control file dictate certain things about the package,
# like its version and size, etc.  This is used to build the .deb file.
# Everything else is just copied (as a tarball) into the data part of the .deb
# file.  
#############################################################################

#######################
# Ensure we are running under fakeroot.
#
# fakeroot(1) is a program which replaces certain system calls in order to
# make them think we are root.  This is not a security hole, it's just a
# feature of how Linux shared library works and it is exploited by the Debian
# packaging system in order to create packages which contain files not owned
# by the current user, even though you're a non-root user.
exec( "fakeroot", "--", $0, @ARGV) unless $<;  

#######################
# Main Program
#
# Get the program name and the command line options.  The command line options
# are used in a lot of places, so it's worth taking a look at the script's
# usage information.
our $SHORT_NAME = basename($0);
our %OPTS       = get_options();
create_debian_package();
exit 0;

# void create_debian_package(void)
#
# Construct a Debian package.
sub create_debian_package {
    my $orig_dir = cwd();
    chdir create_working_directory();
    get_data_from_svn() if defined $OPTS{svn};
    copy_directory_data();
    build_package($orig_dir);
    chdir $orig_dir;
}

# void get_data_from_svn(void)
#
# Export data from SVN if --svn was given.  The data is exported into a
# temporary directory (removed on program exit) and $OPTS{dir} is set (which
# is a bit evil but safe since --dir and --svn are mutually exclusive).
sub get_data_from_svn {
    return unless defined $OPTS{svn};
    my $temp = tempdir( CLEANUP => !$OPTS{debug} );
    my @quiet = $OPTS{debug} ? () : qw(--quiet);
    warn "Exporting $OPTS{svn} to $temp\n" if $OPTS{debug};
    system( "svn", @quiet, "--force", "export", $OPTS{svn}, $temp )
        and die "Could not export $OPTS{svn}";
    $OPTS{dir} = $temp;
    $OPTS{'strip-outer-dir'} = 1;
}

# void create_working_directory(void)
#
# Create a temporary working directory in which to build the package.
sub create_working_directory {
    my $wd = tempdir( CLEANUP => !$OPTS{debug} );
    warn "WORKING DIR IS: $wd\n" if $OPTS{debug};
    return $wd;
}

# void copy_directory_data(void)
#
# Copy the directory given to --dir into the working directory, appending on
# the value of the --root option.  E.g. "--dir ./foo --root /cows" would copy
# "./foo" into "$wd/data/cows/foo", where "$wd/data" is where the package data
# lives in our scratch directory.  The intention is that the files end up on
# the system in "/cows/foo"
sub copy_directory_data {
    my $base = $OPTS{'strip-outer-dir'} ? "" : basename( $OPTS{dir} );
    my $dir = catdir( cwd(), "data", $OPTS{root}, $base );
    make_path($dir);
    dircopy( $OPTS{dir}, $dir )
        or die "Could not copy directory: $!\n";
    
    # If we strip the outer dir then dircopy() perms will be wrong on the last
    # directory.  E.g. src is /foo/bar and dest is /cows.  The result will be
    # /cows/bar, if stip-outer-dir is given.  However, dircopy() will have
    # given "/cows" the same perms as "/foo", which is almost always the wrong
    # thing.
    chmod 0755, $dir if $OPTS{'strip-outer-dir'};
    chown 0, 0, $dir;
}

# void build_package(void)
#
# Create a directory named after --package.
sub build_package {
    my $destdir = shift;
    my $dir = abs_path( catdir( cwd(), $OPTS{package} ) );
    make_path($dir);
    install_files_to_package();
    call_transform_script($dir);
    create_control($dir);
    my $deb = catfile( $destdir, package_filename() );
    run_with_fakeroot( "dpkg-deb", "-b", $dir, $deb );
}

# void install_files_to_package(void)
#
# Copy the files from the scratch directory to the package install directory.
sub install_files_to_package {
    my $prefix = abs_path( catdir( cwd(), $OPTS{package} ) );
    my $is_dir = 1;
    for my $src ( get_dirs(), undef, get_files() ) {
        undef($is_dir), next unless defined $src;
        my $dest = catdir( $prefix, $src );
        $src = catdir( "data", $src );

        # Create/copy the thing in question
        if ($is_dir) {
            make_path($dest);
        }
        else {
            copy( $src, $dest ) or die "Can not copy file: $!\n";
        }

        # Set permissions / ownership
        my $perms = perms( $src, $is_dir ? "dir" : "file" );
        chmod( oct($perms), $dest );
        chown( $OPTS{uid}, $OPTS{gid}, $dest );
    }
}

# void create_control(void)
#
# Creates the Debian control file for the package.  Most of the control file
# is boiler plate, but we do include in the package description a list of
# directories and files that were installed.
sub create_control {
    my $dir      = shift;
    my $version  = version();
    my $size     = get_size();

    # Get a list of all the installed files / directories.  Note this is
    # different than get_files/dirs() since it's after the transform script
    # and doesn't exlude anything.  The map/sort just strips the package name
    # which was included by File::Find::Rule.
    my @dirs  = File::Find::Rule->directory->in( $OPTS{package} );
    my @files = File::Find::Rule->file->in( $OPTS{package} );
    my @content = sort map { s{/?\Q$OPTS{package}\E}{}; $_ } (@dirs, @files);
    my $contents = join( "\n      ", @content );

    make_path( catdir( $dir, "DEBIAN" ) );
    my $control = catfile( $OPTS{package}, "DEBIAN", "control" );
    write_file( $control, <<"CONTENT");
Package: $OPTS{package}
Version: $version
Section: misc
Priority: optional
Architecture: all
Installed-Size: $size
Maintainer: $SHORT_NAME Auto Generated <support\@socialtext.com>
Description: Created by $SHORT_NAME (see full description for contents)
   Package contains the following files and directories:
      $contents
CONTENT
}

# void call_transform_script(String dir)
#
# If a transform script was given then invoke it w/ the absolute path to the
# package data.  This gives the script one last chance to modify the data in
# some way before it's packaged.
sub call_transform_script {
    my $dir    = shift;
    my $script = $OPTS{'transform-script'};
    return unless defined($script);
    system( $script, abs_path($dir) )
        and die "Your transform script failed: $!\n";
}

# void run_with_fakeroot(@command)
#
# Used like system(), but runs the command using fakeroot(1).  So the command
# will believe it is running as root, even though it is not.  This is
# necessary so various bits of the created package have the intended
# permissions.
sub run_with_fakeroot {
    my @cmd = ( "fakeroot", "--", @_ );
    my ( $in, $out, $err ) = ( "", "", "" );
    my $rv = run( \@cmd, \$in, \$out, \$err, timeout(120) );
    my $prog = join( " ", @cmd );
    my $msg = "=== STDOUT: $prog ===\n$out\n=== STDERR: $prog === $err\n\n";
    die "Could not run $prog!  Output:\n$msg" unless $rv;
    warn $msg if $OPTS{debug};
}

# List get_dirs(void)
#
# Returns the list of directories we intend on installing.
sub get_dirs {
    return filter_paths( File::Find::Rule->directory->in("data") );
}

# List get_files(void)
#
# Returns the list of files we intend on installing.
sub get_files {
    return filter_paths( File::Find::Rule->file->in("data") );
}

# List filter_paths(List)
#
# Given a list of paths remove the unwanted ones.  The --exclude option is
# obeyed here, making sure we skip anything that patches an exclude.
sub filter_paths {
    my @results;
ITEM: 
    for my $item ( map { s/^data//; $_ } @_ ) {
        next ITEM if length($item) == 0;
        for my $exclude ( @{ $OPTS{exclude} || [] } ) {
            next ITEM if $item =~ $exclude;
        }
        push @results, $item;
    }
    return @results;
}

# String package_filename(void)
#
# Return the filename for the package, according to the standard Debian naming
# conventions.
sub package_filename {
    my $version = version();
    $version =~ s/^\d+://;
    return "$OPTS{package}_${version}_all.deb";
}

# String get_size(void)
#
# Calculate the size, in kilobytes, of a packages contents.  Return the value.
# This is used by the control file and is calculated using du(1).
sub get_size {
    my $dir = abs_path( catdir( cwd(), $OPTS{package} ) );
    chomp( my $out = `du -s "$dir" 2>/dev/null` || "0" );
    $out =~ s/^(\d+).*$/$1/;
    return $out;
}

# String perms(String $file, String $kind)
#
# $kind is either "file" or "dir".  The intended permissions for $file, when
# installed, are set accordingly:  If --file-perms was given and it's a file
# then those perms are used, otherwise the perms of the file on-disk are used.
# Likewise for --dir-perms when it's a directory.
sub perms {
    my ( $file, $kind ) = @_;
    $kind = "${kind}-perms";
    return $OPTS{$kind} if defined $OPTS{$kind};
    return sprintf "%04o", ( ( stat($file) )[2] & 07777 );
}

# String version(void)
#
# Return a new and hopefully unique Debian package version.  The version is
# 1:YYYYMMDD-SECS_SINCE_EPOCH.  The 1: at the start creates a new package
# epoch (this has nothing to do w/ seconds since the epoch).  The package
# versions *used* to be SECS_SINCE_EPOCH-1 and since YYYYMMDD is numerically
# less than SECS_SINCE_EPOCH it is necessary to create a new package epoch in
# order to use this package version, which is a bit more readable.
#
# This function always returns the same value within the same run of the
# program.
VERSION: {
    my $ver;
    sub version {
        return $ver if defined $ver;
        my $timestamp = strftime( "%Y%m%d", localtime(time) );
        my $epoch = time();
        $ver = "1:$timestamp-$epoch";
        return $ver;
    }
}

# void make_path(String $path)
#
# Like File::Path::mkpath(), but perms are set to 0755 and we die on error.
sub make_path {
    my $path = shift;
    mkpath( $path, 0, 0755 )
        or die "Could not create directory ${path}: $!\n";
}

# HashList get_options(void)
#
# Parses @ARGV for options and returns hash (not a ref to a hash) containing
# all the parsed options.  If options fail to parse, or fail to validate then
# the program exits with an error.  See exit_with_usage() for a description of
# the options.
sub get_options {
    my %opts = (root => '/', owner => 'root', group => 'root', exclude => []);
    GetOptions( \%opts,
        "package|p=s",
        "dir|d=s",
        "svn=s",
        "root|r=s",
        "owner|o=s",
        "group|g=s",
        "dir-perms=s",
        "file-perms=s",
        "exclude|X=s@",  # @ means option can be repeated
        "strip-outer-dir",
        "transform-script=s",
        "debug",
        "help|h=s",
    ) or exit_with_usage("Unknown options");

    # Check if we have help
    exit_with_usage() if $opts{help};

    # Make sure the package name is valid
    $opts{package} = "(undef)" unless defined $opts{package};
    unless ( $opts{package} =~ /^[a-z](?:[a-z0-9.-]*)$/ ) {
        exit_with_usage("Invalid package name: $opts{package}");
    }

    # Make sure both --dir and --svn were not given
    if ( defined( $opts{dir} ) and defined( $opts{svn} ) ) {
        exit_with_usage("--dir and --svn are mutually exclusive");
    }

    # Make sure the directory exists and can be entered
    unless ( defined $opts{svn} ) {
        $opts{dir} = "(undef)" unless defined $opts{dir};
        exit_with_usage("Problem accessing directory: $opts{dir}")
            unless -d $opts{dir}
            and -r _
            and -x _;
        $opts{dir} = abs_path( $opts{dir} );
    }

    # Make sure the owner/group exist.  If the owner/groups were not even
    # passed in then just use roots uid/gid for everything.
    $opts{uid} = defined( $opts{owner} ) ? getpwnam( $opts{owner} ) : 0;
    exit_with_usage("Invalid owner: $opts{owner}") unless defined $opts{uid};
    $opts{gid} = defined( $opts{group} ) ? getgrnam( $opts{group} ) : 0;
    exit_with_usage("Invalid group: $opts{group}") unless defined $opts{gid};

    # Make sure file perms are legal
    if ( defined $opts{'file-perms'} && $opts{'file-perms'} !~ /[0-7]{3,4}/ ) {
        exit_with_usage("Invalid file perms: $opts{'file-perms'}");
    }

    # Make sure dir perms are legal
    if ( defined $opts{'dir-perms'} && $opts{'dir-perms'} !~ /[0-7]{3,4}/ ) {
        exit_with_usage("Invalid dir perms: $opts{'dir-perms'}");
    }

    return %opts;
}

# void exit_with_usage([String $msg])
#
# Print usage information about the program, with an optional message.  Exit
# with a faiure status exit code when done.
sub exit_with_usage {
    my $msg = shift || "";
    $msg .= "\n\n";
    die <<USAGE
${msg}Usage: $0 -p pkg -d dir [-r root] [-h help]

    --dir -d
        The directory that is being packaged.

    --svn
        Instead of giving --dir you can give --svn.  In which case an export
        of the given URL is done first, to a temporary directory, and then
        that temporary directory is acted upon.

    --package -p
        The name of the package to create.  All lower case, first character is
        a letter and the other characters are letters, numbers, dashes or
        dots.

    --root -r
        The root directory all the files should be installed in.  This
        defaults to '/'.

    --owner -o
        The owner for all the files/directories in the package.  Defaults to
        'root'.

    --group -g
        The group for all the files/directories in the package.  Defaults to
        'root'.

    --file-perms
        Force all files to have the given permissions.  Normally the
        permissions default to what they are in the directory being packaged,
        but you can use this to force a homogenous value on all files.
        Permission expressed in octal.

    --dir-perms
        Same as --file-perms but for directories.

    --exclude -X
        Exclude files matching the given Perl regex.  This can be supplied
        multiple times.

    --strip-outer-dir
        If given then just the contents for --dir are installed, not the dir
        itself.  E.g. if we have "--dir ./foo" and "./foo" two files, "cow"
        and "love", then only "cow" and "love" are installed, not "foo".  E.g.
        so in this case /cow and /love would be installed.

    --transform-script
        The given script is invoked with the path to the package data as a
        command line argument.  This is done right before the package is
        built, so this script has one last chance to munge any data it might
        munge.  This is useful if you're building a package from a directory
        which you don't want to modify directly, but modifications are
        necessary for the files to be installed right.  Defaults to a no-op.

    --debug
        Print out helpful information and preserve build files so maintainers
        can figure out what went wrong.
USAGE
}
