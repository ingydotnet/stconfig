#!/bin/bash -e

usage() {
    cat <<END_OF_HELP
USAGE:
    test-branch add stable-1.8.1
    test-branch (remove|rm) exp-ruby-rewrite
    test-branch status trunk
    test-branch htstatus stable-1.8.2
    test-branch (list|ls)
END_OF_HELP
    exit 0
}

verb="$1"
branch="$2"

DIR=$(dirname $0)
CHECKOUTS=~testrunner/checkouts
PATH=$PATH:~testrunner/testrunner-bin
export PATH

case "$verb" in
    (a|ad|add)
        [ -z "$branch" ] && usage
        [ ! -d ~testrunner/$branch ]
        [ ! -d ~testrunner/$CHECKOUTS/$branch ]
        if [ "$branch" = "trunk" ]; then
            branch_path="trunk"
        else
            branch_path="branches/$branch"
        fi
        sudo su - testrunner "
            LANG=en_US.UTF-8 \
            svn co $ST_CODE_REPO/$branch_path \
            && mv $branch $CHECKOUTS
        "
        ;;
    (r|rm|re|rem|remo|remov|remove)
        [ -z "$branch" ] && usage
        sudo su - testrunner "
            mv $CHECKOUTS/$branch . \
            && rm -fr $branch
        "
        ;;
    (s|st|sta|stat|statu|status)
        [ -z "$branch" ] && usage
        DB="$CHECKOUTS/$branch/test.db"
        [ -f "$DB" -a -f "$DB.lock" ] || exit 1;
        db2lines "$DB" \
        | perl -F, -alne ' 
            eval qq( \$$F[0]\{\$F[1]\} = \$F[2] );
            END {
                foreach $test (sort keys %status) {
                    $lastpass{$test} ||= "NEVER";
                    print
                        $status{$test} eq q(passing) ? q(+) : q(-),
                        "$lastpass{$test} $test";
                }
            }
        '
        ;;
    (hti|htin|htind|htinde|htindex)
        echo '<TITLE>testrunner report index</TITLE>'
        echo '<TABLE>'
        for branch in $($0 ls); do
            branch=$(echo $branch | perl -pe 's,/$,,')
            html_file="${branch}.html"
            trouble_file="$CHECKOUTS/$branch/TROUBLE"
            output_file="${branch}-output.txt"
            if [ -f "$html_file" ]; then
                echo "<TR><TD><A href="$html_file">$branch</A></TD>"
                if [ -e "$trouble_file" ]; then
                    color='goldenrod'
                    stamp_file="$trouble_file"
                else
                    stamp_file="$html_file"
                    if $0 status $branch | egrep -q '^-' ; then
                        color='red'
                    else
                        color='green'
                    fi
                fi
                echo "<TD STYLE='background-color: $color'>"
                echo -n "<A href='$output_file'"
                echo -n " STYLE='color: white; background-color: $color'>"
                ls -l $stamp_file | awk '{print $6 " " $7}'
                echo '</TD></TR>'
            fi
        done
        echo '</TABLE>'
        if [ focused ]
        then
            FOCUS=`cat ~testrunner/FOCUS`
            cat<<EOF
<p><b>The testrunner is currently focused on $FOCUS.</b></p>
EOF
        fi
	cat <<EOF
<p>If you want to add a new branch for testing log in to testrunner.socialtext.net and use
the <code>test-branch</code> command.</p>
<p>You should add your branch to the testrunner if you think this is a branch that will be used
for active development for more than a few days.  If you're just doing a quick fix, you don't need
to add it to testrunner, the Release Gang will run your tests before merging your branch to trunk.  
Please don't use that as an excuse to not run the tests yourself.</p>
<p>After your <em>Work Is Done</em> you might want to remove your branch from the testrunner loop.
Again, you use test-branch to do that.  If you're lazy, you can mention on the Release Contract that
you'd like the Release Gang to clean up for you.</p>
EOF
        ;;
    (hts|htst|htsta|htstat|htstatu|htstatus)
        [ -z "$branch" ] && usage
        trouble_file="$CHECKOUTS/$branch/TROUBLE"
        if [ -e "$trouble_file" ]; then
            trouble_message="<SPAN STYLE='background-color: goldenrod; color: white'>&nbsp;IN TROUBLE&nbsp;</SPAN>"
        else
            trouble_message=''
        fi
        db2lines $CHECKOUTS/$branch/test.db \
        | perl -F, -alne ' 
            eval qq( \$$F[0]\{\$F[1]\} = \$F[2] );
            END {
                print
                    qq(<TITLE>'"$branch"'</TITLE>\n),
                    q(<TABLE>),
                    q(<TR><TH colspan=2>'"$branch$trouble_message"'</TH>),
                    q(<TH colspan=4>'"$(date +%Y-%m-%d\ %H:%M:%S)"'),
                    q(</TH></TR>);
                $i = 0;
                foreach $test (sort keys %status) {
                    $lastpass{$test} ||= "NEVER";
                    ++$i;
                    print q(<TR>) if ($i % 3 == 1);
                    print
                        q(<TD STYLE="color: white; background-color: ),
                        $status{$test} eq q(passing) ? q(green) : q(red),
                        qq(">$lastpass{$test}</TD><TD>),
                        qq(<A HREF="'"$branch"'/$test-out.txt">$test</A></TD>);
                }
                print q(</TABLE>);
            }
        '
        ;;
    (l|ls|li|lis|list)
        cd $CHECKOUTS
        ls -1d */
        ;;
    (*)
        usage
        ;;
esac
