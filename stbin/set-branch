#!/usr/bin/perl
use strict;
use warnings;
use Term::ANSIColor 'color';
use File::Path qw/mkpath/;
use Fatal qw/:void mkpath chdir unlink symlink/;
use English;
use List::Util qw(first);

my @repos = grep { !m/^socialpoint/ } split /\s+/, qx(st-repo-list);
my $branch = shift || '';

if ($branch eq 'trunk') {
    warn color('red') . "Warning:". color('reset')
        . " you are attempting to use the deprecated 'trunk' branch.\n";
    warn "In the future use 'master'. Substituting 'master' for 'trunk'.\n\n";
    $branch = 'master';
}

my $private = shift;

my $git_base = $ENV{ST_GIT};
my $src_base = $ENV{ST_SRC_BASE};
unless (-d $src_base) {
    mkpath $src_base;
}

$branch = num_to_name($branch) if $branch =~ m/^\d+$/;
usage() unless $branch;

if ($branch =~ s#^tags/##) {
    checkout($branch, 1);
}
else {
    checkout($branch);
}

my $branch_dir = "$src_base/$branch";
if (-d $branch_dir) {
    my $curlink = "$src_base/current";
    unlink $curlink if -l $curlink;
    symlink $branch_dir, $curlink;
}

exit;

sub checkout {
    my $branch = shift;
    my $tag    = shift;
    chdir $src_base;

    if (-d "$branch/.git") {
        shell_run("refresh-branch $branch");
    }
    else {
        assert_branch_exists("$src_base/master", $branch)
            unless ($branch eq 'master');
        checkout_repo($_, $branch, $tag) for @repos;
    }
}

sub checkout_repo {
    my ($repo, $branch, $tag) = @_;
    my $repo_dir = $repo eq 'socialtext' ? $branch : "$branch/$repo";
    my $dir      = "$src_base/$repo_dir";
    my $from     = $tag ? $branch : "origin/$branch";

    (my $master_repo = $dir) =~ s/$branch/master/;
    if (-d "$master_repo/.git") {
        (my $to_clone = $repo_dir) =~ s/$branch/master/;
        shell_run("git clone --local $src_base/$to_clone $dir");
        chdir $dir;
        shell_run("git remote rm origin"); # dis-associate from local master
        shell_run("git remote add origin $git_base/$repo.git"); #associate with remote
        shell_run("git fetch 2>&1 | grep -v 'new branch'");# | grep -v '^From'");
        chdir '..';
    }
    else {
        shell_run("git clone $git_base/$repo.git $dir\n");
    }

    if ($branch ne 'master') {
        my $track_opt = $tag ? ''      : '--track';
        shell_run("cd $dir; git checkout $track_opt -b $branch $from");
    }
}

sub assert_branch_exists {
    my ($repo_dir, $branch) = @_;
    # check if the branch exists, exit if not
    my @branches = map { s/^[* ]*//g; $_ } split "\n", `cd $repo_dir; git branch -r`;
    if (!first { m|^(?:origin/)?$branch$| } @branches) {
        warn color("red") . "Couldn't find a local or upstream branch, '$branch'" . color("reset") . "\n";
        exit 1;
    }
}
sub shell_run {
    my $cmd = shift;
    my $nodie = $cmd =~ s/^-//;
    warn "+ $cmd\n" if $cmd =~ m/git/;
    my $rc = system $cmd;
    unless ($nodie or $rc == 0) {
        color_print('red', "Error running $cmd\n");
        exit $rc;
    }
    return $rc == 0;
}

sub num_to_name {
    my $num = shift;
    my @branches = branch_list();
    $num--; # was 1 based
    return $branches[$num];
}

sub usage {
    my $i = 1;
    my @branches = map { sprintf('  %2d - %s', $i++, $_) } branch_list();
    
    (my $current = readlink("$src_base/current")) =~ s#.+/##;
    @branches = map { s/^\s(\s+\d+\s\-\s\Q$current\E)$/*$1/; $_ } @branches;

    local $LIST_SEPARATOR = "\n";
    die <<EOT;
USAGE: set-branch <branch>

Existing branches:
@branches
EOT
}

sub color_print {
    my $color = shift;
    my $msg = shift;
    print color($color), $msg, color('reset');
}

sub branch_list {
    my @branches = sort glob("$src_base/*/nlw");
    return grep { $_ ne 'current' }
        map { s#.+/(.+)/nlw#$1#; $_ } @branches;
}
