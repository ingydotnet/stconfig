#!/usr/bin/perl
use strict;
use warnings;
use Term::ANSIColor 'color';
use File::Path qw/mkpath/;
use Fatal qw/:void mkpath chdir unlink symlink/;
use English;
use List::Util qw(first);

my $branch = shift || '';

if ($branch eq 'trunk') {
    warn color('red') . "Warning:". color('reset')
        . " you are attempting to use the deprecated 'trunk' branch.\n";
    warn "In the future use 'master'. Substituting 'master' for 'trunk'.\n\n";
    $branch = 'master';
}

my $private = shift;

my $git_base = $ENV{ST_GIT};
my $src_base = $ENV{ST_SRC_BASE};
unless (-d $src_base) {
    mkpath $src_base;
}
my @repos = (split /\s+/,`st-repo-list`);
chomp @repos;

$branch = num_to_name($branch) if $branch =~ m/^\d+$/;
usage() unless $branch;
$branch =~ s#^tags/##;

chdir $src_base;
my $current = readlink "$src_base/current";

# TODO: if current/$repo doesn't exist, clone it?

git_all('fetch');

assert_branch_exists($branch);

git_all(qq{\@stash save 'auto-stash for set-branch'});
git_all(qq{\@checkout --track -q -b $branch origin/$branch});

# move the working directory to its new name
shell_run(qq{mv $current $branch}) if $current;
shell_run(qq{ln -sf $branch current});

$current = "$src_base/$branch";

foreach my $repo (@repos) {
    $repo = '' if $repo eq 'socialtext';
    next unless -d "$src_base/current/$repo";

    chdir "$src_base/current/$repo";

    my $latest = first { /On \Q$branch\E: auto-stash/ } `git stash list`;
    next unless $latest;
    $latest =~ s/:.+//;

    shell_run(qq{git stash apply --index $latest >/dev/null});
    shell_run(qq{git stash drop $latest >/dev/null});
}

chdir $current;

exit;

sub assert_branch_exists {
    # check if the branch exists, exit if not
    my @branches = map { s/^[* ]*//g; $_ } 
                   split "\n", `cd $src_base/current; git branch -r`;
    if (!first { m|^(?:origin/)?$branch$| } @branches) {
        warn color("red") . "Couldn't find a local or upstream branch, '$branch'" . color("reset") . "\n";
        exit 1;
    }
}

sub git_all {
    my $cmd = shift;
    shell_run("st-git-all $cmd");
}

sub shell_run {
    my $cmd = shift;
    my $nodie = $cmd =~ s/^-//;
    warn "+ $cmd\n" if $cmd =~ m/git/;
    my $rc = system $cmd;
    unless ($rc == 0) {
        color_print('red', "Error running $cmd\n");
        exit $rc unless $nodie;
    }
    return $rc == 0;
}

sub num_to_name {
    my $num = shift;
    my @branches = branch_list();
    $num--; # was 1 based
    return $branches[$num];
}

sub usage {
    my $i = 1;
    my @branches = map { sprintf('  %2d - %s', $i++, $_) } branch_list();
    
    local $LIST_SEPARATOR = "\n";
    die <<EOT;
USAGE: set-branch <branch>

Existing branches:
@branches
EOT
}

sub color_print {
    my $color = shift;
    my $msg = shift;
    print color($color), $msg, color('reset');
}

sub branch_list {
    # cd current; git branch | sort
    # or
    # cd current; git branch -r | sort
    my @branches = `cd $src_base/current; git branch | sort`;
    return @branches;
}
